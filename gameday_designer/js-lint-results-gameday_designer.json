[{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/App.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/__tests__/App.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/api/__tests__/designerApi.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/api/__tests__/gamedayApi-coverage.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/api/__tests__/gamedayApi.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/api/designerApi.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/api/gamedayApi.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/api/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/api/mockGamedayApi.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/components/DesignerCanvas.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/components/FieldColumn.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/components/FieldSidebar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/components/FlowToolbar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/components/GameSlotCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/components/GameSlotEditor.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/components/GamedayMetadataAccordion.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/components/LanguageSelector.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/components/ListCanvas.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/components/ListDesignerApp.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/components/NotificationToast.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/components/TeamSelector.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/components/ValidationPanel.tsx","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":36,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":36,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1162,1165],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1162,1165],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/components/__tests__/AutoClearOnGenerate.test.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":69,"column":71,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":69,"endColumn":74,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2596,2599],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2596,2599],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, it, expect, vi, beforeEach } from 'vitest';\nimport { render, screen, waitFor, within } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport { MemoryRouter, Routes, Route } from 'react-router-dom';\nimport ListDesignerApp from '../ListDesignerApp';\nimport AppHeader from '../layout/AppHeader';\nimport { GamedayProvider } from '../../context/GamedayContext';\nimport i18n from '../../i18n/testConfig';\nimport { gamedayApi } from '../../api/gamedayApi';\n\n// Mock react-router-dom\nvi.mock('react-router-dom', async (importOriginal) => {\n  const actual = await importOriginal<typeof import('react-router-dom')>();\n  return {\n    ...actual,\n    useParams: () => ({ id: '1' }),\n    useNavigate: () => vi.fn(),\n  };\n});\n\n// Mock gamedayApi\nvi.mock('../../api/gamedayApi', () => ({\n  gamedayApi: {\n    getGameday: vi.fn(),\n    publish: vi.fn(),\n    patchGameday: vi.fn(),\n    deleteGameday: vi.fn(),\n    updateGameResult: vi.fn(),\n    listSeasons: vi.fn().mockResolvedValue([]),\n    listLeagues: vi.fn().mockResolvedValue([]),\n  },\n}));\n\ndescribe('Auto-Clear on Generate Integration', () => {\n  const mockGameday = {\n    id: 1,\n    name: 'Auto-Clear Test',\n    date: '2026-06-01',\n    start: '10:00',\n    format: '6_2',\n    author: 1,\n    address: 'Field',\n    season: 1,\n    league: 1,\n    status: 'DRAFT',\n    designer_data: {\n      nodes: [\n        { id: 'game-old', type: 'game', parentId: 'stage-old', data: { standing: 'Old Game', order: 0 }, position: { x: 0, y: 0 } },\n        { id: 'stage-old', type: 'stage', parentId: 'field-old', data: { name: 'Old Stage', order: 0 }, position: { x: 0, y: 0 } },\n        { id: 'field-old', type: 'field', data: { name: 'Old Field', order: 0 }, position: { x: 0, y: 0 } }\n      ],\n      edges: [],\n      fields: [{ id: 'field-old', name: 'Old Field', order: 0 }],\n      globalTeams: [\n        { id: 't1', label: 'Team 1', color: '#000', order: 0, groupId: 'g1' },\n        { id: 't2', label: 'Team 2', color: '#000', order: 1, groupId: 'g1' },\n        { id: 't3', label: 'Team 3', color: '#000', order: 2, groupId: 'g1' },\n        { id: 't4', label: 'Team 4', color: '#000', order: 3, groupId: 'g1' },\n        { id: 't5', label: 'Team 5', color: '#000', order: 4, groupId: 'g1' },\n        { id: 't6', label: 'Team 6', color: '#000', order: 5, groupId: 'g1' },\n      ],\n      globalTeamGroups: [{ id: 'g1', name: 'Group 1', order: 0 }],\n    }\n  };\n\n  beforeEach(async () => {\n    await i18n.changeLanguage('en');\n    vi.clearAllMocks();\n    vi.mocked(gamedayApi.getGameday).mockResolvedValue(mockGameday as any);\n  });\n\n  const renderApp = async () => {\n    const user = userEvent.setup();\n    render(\n      <MemoryRouter initialEntries={['/designer/1']}>\n        <GamedayProvider>\n          <AppHeader />\n          <Routes>\n            <Route path=\"/designer/:id\" element={<ListDesignerApp />} />\n          </Routes>\n        </GamedayProvider>\n      </MemoryRouter>\n    );\n    await waitFor(() => expect(screen.queryByRole('status')).not.toBeInTheDocument(), { timeout: 15000 });\n    return { user };\n  };\n\n  it('RED: should clear existing structure when tournament is generated', async () => {\n    const { user } = await renderApp();\n\n    // Verify old structure exists\n    expect(screen.getByText('Old Field')).toBeInTheDocument();\n    expect(screen.getByText('Old Game')).toBeInTheDocument();\n\n    // 1. Open Modal\n    const generateBtn = (await screen.findAllByRole('button', { name: /generate tournament/i }))[0];\n    await user.click(generateBtn);\n\n    // 2. Select Template\n    const modal = await screen.findByRole('dialog');\n    \n    // 3. Generate\n    const confirmBtn = within(modal).getByTestId('confirm-generate-button');\n    await user.click(confirmBtn);\n\n    // 4. Verify old structure is GONE and new structure is present\n    await waitFor(() => {\n      // Check for presence of some game rows (e.g. from default F6-2-2)\n      // Actually F3-RR creates games like \"Team 1 vs Team 2\" etc.\n      const gameRows = document.querySelectorAll('tr[id^=\"game-\"]');\n      expect(gameRows.length).toBeGreaterThan(0);\n      \n      // OLD STRUCTURE SHOULD BE GONE\n      expect(screen.queryByText('Old Field')).toBeNull();\n      expect(screen.queryByText('Old Game')).toBeNull();\n    }, { timeout: 10000 });\n  }, 30000);\n});","usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/components/__tests__/DesignerCanvas.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/components/__tests__/FieldColumn.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/components/__tests__/FieldSidebar.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/components/__tests__/FinalCoveragePolish.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/components/__tests__/FlowToolbar-containers.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/components/__tests__/FlowToolbar.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/components/__tests__/GameSlotCard.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/components/__tests__/GameSlotEditor.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/components/__tests__/GamedayMetadataAccordion-coverage.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/components/__tests__/GamedayMetadataAccordion.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/components/__tests__/LanguageSelector.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/components/__tests__/ListCanvas.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/components/__tests__/ListDesignerApp-coverage.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/components/__tests__/ListDesignerApp-e2e.test.tsx","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'_' is defined but never used.","line":201,"column":61,"nodeType":"Identifier","messageId":"unusedVar","endLine":201,"endColumn":62,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/components/__tests__/ListDesignerApp-integration.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/components/__tests__/ListDesignerApp-placement.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/components/__tests__/ListDesignerApp.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/components/__tests__/NotificationToast-coverage.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/components/__tests__/NotificationToast.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/components/__tests__/TeamSelector.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/components/__tests__/TournamentProgression.integration.test.tsx","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":66,"column":143,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":66,"endColumn":146,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2308,2311],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2308,2311],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":66,"column":149,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":66,"endColumn":152,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2314,2317],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2314,2317],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/components/__tests__/ValidationPanel.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/components/dashboard/GamedayCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/components/dashboard/GamedayDashboard.tsx","messages":[],"suppressedMessages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'loadGamedays'. Either include it or remove the dependency array.","line":221,"column":6,"nodeType":"ArrayExpression","endLine":221,"endColumn":18,"suggestions":[{"desc":"Update the dependencies array to be: [loadGamedays, searchTerm]","fix":{"range":[7913,7925],"text":"[loadGamedays, searchTerm]"}}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/components/dashboard/__tests__/GamedayCard-coverage.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/components/dashboard/__tests__/GamedayCard.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/components/dashboard/__tests__/GamedayDashboard-coverage.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/components/dashboard/__tests__/GamedayDashboard.test.tsx","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":111,"column":139,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":111,"endColumn":142,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3450,3453],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3450,3453],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":111,"column":145,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":111,"endColumn":148,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3456,3459],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3456,3459],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":111,"column":151,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":111,"endColumn":154,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3462,3465],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3462,3465],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/components/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/components/layout/AppHeader.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/components/layout/MainLayout.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/components/layout/__tests__/AppHeader.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/components/list/FieldSection.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/components/list/GameTable.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/components/list/GlobalTeamTable.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/components/list/StageSection.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/components/list/TeamGroupCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/components/list/__tests__/FieldSection.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/components/list/__tests__/GameTable-dynamic-refs.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/components/list/__tests__/GameTable.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/components/list/__tests__/GlobalTeamTable.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/components/list/__tests__/StageSection.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/components/list/__tests__/TeamGroupCard-interaction.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/components/list/__tests__/TeamGroupCard.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/components/modals/GameResultModal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/components/modals/PublishConfirmationModal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/components/modals/TournamentGeneratorModal.tsx","messages":[],"suppressedMessages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'resetForm'. Either include it or remove the dependency array.","line":92,"column":8,"nodeType":"ArrayExpression","endLine":92,"endColumn":14,"suggestions":[{"desc":"Update the dependencies array to be: [resetForm, show]","fix":{"range":[3039,3045],"text":"[resetForm, show]"}}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/components/modals/__tests__/GameResultModal.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/components/modals/__tests__/TournamentGeneratorModal-defaults.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/components/modals/__tests__/TournamentGeneratorModal-reset.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/components/modals/__tests__/TournamentGeneratorModal-validation.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/components/modals/__tests__/TournamentGeneratorModal.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/context/GamedayContext.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/hooks/__tests__/useDesigner.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/hooks/__tests__/useDesignerController.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/hooks/__tests__/useEdgesState.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/hooks/__tests__/useFlowState-containers.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/hooks/__tests__/useFlowState-edge-cases.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/hooks/__tests__/useFlowState-edge-management.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/hooks/__tests__/useFlowState-global-teams.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/hooks/__tests__/useFlowState-manual-colors.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/hooks/__tests__/useFlowState-time-updates.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/hooks/__tests__/useFlowValidation-capacity.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/hooks/__tests__/useFlowValidation-distribution.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/hooks/__tests__/useFlowValidation-i18n.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/hooks/__tests__/useFlowValidation-overlaps.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/hooks/__tests__/useFlowValidation-progression.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/hooks/__tests__/useFlowValidation-sequence.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/hooks/__tests__/useFlowValidation-warnings.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/hooks/__tests__/useFlowValidation.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1292,"column":76,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1292,"endColumn":79,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[41351,41354],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[41351,41354],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1301,"column":70,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1301,"endColumn":73,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[41768,41771],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[41768,41771],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1310,"column":75,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1310,"endColumn":78,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[42196,42199],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[42196,42199],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1319,"column":80,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1319,"endColumn":83,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[42655,42658],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[42655,42658],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Tests for useFlowValidation Hook\n *\n * TDD RED Phase: Comprehensive tests for flowchart validation logic\n *\n * Coverage targets:\n * - Incomplete game inputs detection\n * - Circular dependency detection\n * - Official playing validation\n * - Duplicate standing names\n * - Orphaned teams\n * - Unassigned fields\n * - Container hierarchy validation (v2 model)\n * - Dynamic reference validation\n */\n\nimport { describe, it, expect } from 'vitest';\nimport { renderHook } from '@testing-library/react';\nimport { useFlowValidation } from '../useFlowValidation';\nimport type { FlowNode, FlowEdge, GameToGameEdge, TeamToGameEdge } from '../../types/flowchart';\n\nconst validMetadata = { id: 1, name: 'Test', date: '2026-01-01', start: '10:00', status: 'DRAFT', format: '6_2', author: 1, address: 'Field', season: 1, league: 1 };\n\ndescribe('useFlowValidation', () => {\n  describe('Valid Flowchart', () => {\n    it('should return valid for empty flowchart with warnings', () => {\n      const { result } = renderHook(() => useFlowValidation([], [], [], [], [], validMetadata));\n\n      expect(result.current.isValid).toBe(true);\n      expect(result.current.errors).toHaveLength(0);\n      expect(result.current.warnings).toHaveLength(2); // no_teams and no_games\n    });\n\n    it('should return valid for complete game with team assignments', () => {\n      const nodes: FlowNode[] = [\n        {\n          id: 'field1',\n          type: 'field',\n          data: { name: 'Field 1', order: 0 },\n          position: { x: 0, y: 0 },\n        },\n        {\n          id: 'stage1',\n          type: 'stage',\n          parentId: 'field1',\n          data: { name: 'Stage 1', order: 0, progressionMode: 'manual' },\n          position: { x: 0, y: 0 },\n        },\n        {\n          id: 'game1',\n          type: 'game',\n          parentId: 'stage1',\n          data: {\n            standing: 'Game 1',\n            homeTeamId: 'team1',\n            awayTeamId: 'team2',\n            fieldId: 'field1',\n            official: null,\n            startTime: null,\n          },\n          position: { x: 0, y: 0 },\n        },\n      ];\n\n      const { result } = renderHook(() => useFlowValidation(nodes, [], [], [], [], validMetadata));\n\n      expect(result.current.isValid).toBe(true);\n      expect(result.current.errors).toHaveLength(0);\n    });\n\n    it('should return valid for game with dynamic references', () => {\n      const nodes: FlowNode[] = [\n        {\n          id: 'field1',\n          type: 'field',\n          data: { name: 'Field 1', order: 0 },\n          position: { x: 0, y: 0 },\n        },\n        {\n          id: 'stage1',\n          type: 'stage',\n          parentId: 'field1',\n          data: { name: 'Stage 1', order: 0, progressionMode: 'manual' },\n          position: { x: 0, y: 0 },\n        },\n        {\n          id: 'game1',\n          type: 'game',\n          parentId: 'stage1',\n          data: {\n            standing: 'Game 1',\n            homeTeamId: 'team1',\n            awayTeamId: 'team2',\n            fieldId: 'field1',\n            official: null,\n            startTime: null,\n          },\n          position: { x: 0, y: 0 },\n        },\n        {\n          id: 'game2',\n          type: 'game',\n          parentId: 'stage1',\n          data: {\n            standing: 'Game 2',\n            homeTeamDynamic: { type: 'winner', matchName: 'Game 1' },\n            awayTeamDynamic: { type: 'loser', matchName: 'Game 1' },\n            fieldId: 'field1',\n            official: null,\n            startTime: null,\n          },\n          position: { x: 0, y: 0 },\n        },\n      ];\n\n      const edges: FlowEdge[] = [\n        {\n          id: 'edge1',\n          type: 'game-to-game',\n          source: 'game1',\n          target: 'game2',\n          sourceHandle: 'winner',\n          targetHandle: 'home',\n          data: { outputType: 'winner' },\n        } as GameToGameEdge,\n        {\n          id: 'edge2',\n          type: 'game-to-game',\n          source: 'game1',\n          target: 'game2',\n          sourceHandle: 'loser',\n          targetHandle: 'away',\n          data: { outputType: 'loser' },\n        } as GameToGameEdge,\n      ];\n\n      const { result } = renderHook(() => useFlowValidation(nodes, edges, [], [], [], validMetadata));\n\n      expect(result.current.isValid).toBe(true);\n      expect(result.current.errors).toHaveLength(0);\n    });\n  });\n\n  describe('Incomplete Game Inputs', () => {\n    it('should detect game missing home team', () => {\n      const nodes: FlowNode[] = [\n        {\n          id: 'field1',\n          type: 'field',\n          data: { name: 'Field 1', order: 0 },\n          position: { x: 0, y: 0 },\n        },\n        {\n          id: 'stage1',\n          type: 'stage',\n          parentId: 'field1',\n          data: { name: 'Stage 1', order: 0, progressionMode: 'manual' },\n          position: { x: 0, y: 0 },\n        },\n        {\n          id: 'game1',\n          type: 'game',\n          parentId: 'stage1',\n          data: {\n            standing: 'Game 1',\n            homeTeamId: null,\n            awayTeamId: 'team2',\n            fieldId: 'field1',\n            official: null,\n            startTime: null,\n          },\n          position: { x: 0, y: 0 },\n        },\n      ];\n\n      const { result } = renderHook(() => useFlowValidation(nodes, [], [], [], [], validMetadata));\n\n      expect(result.current.isValid).toBe(false);\n      expect(result.current.errors).toHaveLength(1);\n      expect(result.current.errors[0].type).toBe('incomplete_game_inputs');\n      expect(result.current.errors[0].message).toContain('home');\n    });\n\n    it('should detect game missing away team', () => {\n      const nodes: FlowNode[] = [\n        {\n          id: 'field1',\n          type: 'field',\n          data: { name: 'Field 1', order: 0 },\n          position: { x: 0, y: 0 },\n        },\n        {\n          id: 'stage1',\n          type: 'stage',\n          parentId: 'field1',\n          data: { name: 'Stage 1', order: 0, progressionMode: 'manual' },\n          position: { x: 0, y: 0 },\n        },\n        {\n          id: 'game1',\n          type: 'game',\n          parentId: 'stage1',\n          data: {\n            standing: 'Game 1',\n            homeTeamId: 'team1',\n            awayTeamId: null,\n            fieldId: 'field1',\n            official: null,\n            startTime: null,\n          },\n          position: { x: 0, y: 0 },\n        },\n      ];\n\n      const { result } = renderHook(() => useFlowValidation(nodes, [], [], [], [], validMetadata));\n\n      expect(result.current.isValid).toBe(false);\n      expect(result.current.errors).toHaveLength(1);\n      expect(result.current.errors[0].type).toBe('incomplete_game_inputs');\n      expect(result.current.errors[0].message).toContain('away');\n    });\n\n    it('should detect game missing both teams', () => {\n      const nodes: FlowNode[] = [\n        {\n          id: 'field1',\n          type: 'field',\n          data: { name: 'Field 1', order: 0 },\n          position: { x: 0, y: 0 },\n        },\n        {\n          id: 'stage1',\n          type: 'stage',\n          parentId: 'field1',\n          data: { name: 'Stage 1', order: 0, progressionMode: 'manual' },\n          position: { x: 0, y: 0 },\n        },\n        {\n          id: 'game1',\n          type: 'game',\n          parentId: 'stage1',\n          data: {\n            standing: 'Game 1',\n            homeTeamId: null,\n            awayTeamId: null,\n            fieldId: 'field1',\n            official: null,\n            startTime: null,\n          },\n          position: { x: 0, y: 0 },\n        },\n      ];\n\n      const { result } = renderHook(() => useFlowValidation(nodes, [], [], [], [], validMetadata));\n\n      expect(result.current.isValid).toBe(false);\n      expect(result.current.errors).toHaveLength(1);\n      expect(result.current.errors[0].type).toBe('incomplete_game_inputs');\n      expect(result.current.errors[0].message).toContain('home and away');\n    });\n\n    it('should not flag incomplete when game has edge connection', () => {\n      const nodes: FlowNode[] = [\n        {\n          id: 'field1',\n          type: 'field',\n          data: { name: 'Field 1', order: 0 },\n          position: { x: 0, y: 0 },\n        },\n        {\n          id: 'stage1',\n          type: 'stage',\n          parentId: 'field1',\n          data: { name: 'Stage 1', order: 0, progressionMode: 'manual' },\n          position: { x: 0, y: 0 },\n        },\n        {\n          id: 'game1',\n          type: 'game',\n          parentId: 'stage1',\n          data: {\n            standing: 'Game 1',\n            homeTeamId: 'team1',\n            awayTeamId: 'team2',\n            fieldId: 'field1',\n            official: null,\n            startTime: null,\n          },\n          position: { x: 0, y: 0 },\n        },\n        {\n          id: 'game2',\n          type: 'game',\n          parentId: 'stage1',\n          data: {\n            standing: 'Game 2',\n            homeTeamId: null,\n            awayTeamId: null,\n            fieldId: 'field1',\n            official: null,\n            startTime: null,\n          },\n          position: { x: 0, y: 0 },\n        },\n      ];\n\n      const edges: FlowEdge[] = [\n        {\n          id: 'edge1',\n          type: 'game-to-game',\n          source: 'game1',\n          target: 'game2',\n          sourceHandle: 'winner',\n          targetHandle: 'home',\n          data: { outputType: 'winner' },\n        } as GameToGameEdge,\n        {\n          id: 'edge2',\n          type: 'game-to-game',\n          source: 'game1',\n          target: 'game2',\n          sourceHandle: 'loser',\n          targetHandle: 'away',\n          data: { outputType: 'loser' },\n        } as GameToGameEdge,\n      ];\n\n      const { result } = renderHook(() => useFlowValidation(nodes, edges, [], [], [], validMetadata));\n\n      expect(result.current.isValid).toBe(true);\n      expect(result.current.errors).toHaveLength(0);\n    });\n  });\n\n  describe('Circular Dependencies', () => {\n    it('should detect simple circular dependency', () => {\n      const nodes: FlowNode[] = [\n        {\n          id: 'field1',\n          type: 'field',\n          data: { name: 'Field 1', order: 0 },\n          position: { x: 0, y: 0 },\n        },\n        {\n          id: 'stage1',\n          type: 'stage',\n          parentId: 'field1',\n          data: { name: 'Stage 1', order: 0, progressionMode: 'manual' },\n          position: { x: 0, y: 0 },\n        },\n        {\n          id: 'game1',\n          type: 'game',\n          parentId: 'stage1',\n          data: {\n            standing: 'Game 1',\n            homeTeamId: null,\n            homeTeamDynamic: { type: 'winner', matchName: 'Game 2' },\n            awayTeamId: null,\n            fieldId: 'field1',\n            official: null,\n            startTime: null,\n          },\n          position: { x: 0, y: 0 },\n        },\n        {\n          id: 'game2',\n          type: 'game',\n          parentId: 'stage1',\n          data: {\n            standing: 'Game 2',\n            homeTeamId: null,\n            homeTeamDynamic: { type: 'winner', matchName: 'Game 1' },\n            awayTeamId: null,\n            fieldId: 'field1',\n            official: null,\n            startTime: null,\n          },\n          position: { x: 0, y: 0 },\n        },\n      ];\n\n      const edges: FlowEdge[] = [\n        {\n          id: 'edge1',\n          type: 'gameToGame',\n          source: 'game1',\n          target: 'game2',\n          sourceHandle: 'winner',\n          targetHandle: 'home',\n          data: { sourcePort: 'winner', targetPort: 'home' },\n        } as GameToGameEdge,\n        {\n          id: 'edge2',\n          type: 'gameToGame',\n          source: 'game2',\n          target: 'game1',\n          sourceHandle: 'winner',\n          targetHandle: 'home',\n          data: { sourcePort: 'winner', targetPort: 'home' },\n        } as GameToGameEdge,\n      ];\n\n      const { result } = renderHook(() => useFlowValidation(nodes, edges, [], [], [], validMetadata));\n\n      expect(result.current.isValid).toBe(false);\n      expect(result.current.errors.length).toBeGreaterThanOrEqual(1);\n      const circularError = result.current.errors.find(e => e.type === 'circular_dependency');\n      expect(circularError).toBeDefined();\n      expect(circularError?.message).toContain('Circular dependency');\n    });\n\n    it('should detect longer circular dependency chain', () => {\n      // ... existing test ...\n    });\n\n    it('should handle independent paths to the same node without flagging a cycle', () => {\n      const nodes: FlowNode[] = [\n        {\n          id: 'field1',\n          type: 'field',\n          data: { name: 'Field 1', order: 0 },\n          position: { x: 0, y: 0 },\n        },\n        {\n          id: 'stage1',\n          type: 'stage',\n          parentId: 'field1',\n          data: { name: 'Stage 1', order: 0 },\n          position: { x: 0, y: 0 },\n        },\n        { id: 'g1', type: 'game', parentId: 'stage1', data: { standing: 'G1', homeTeamId: 't1', awayTeamId: 't2' }, position: { x: 0, y: 0 } },\n        { id: 'g2', type: 'game', parentId: 'stage1', data: { standing: 'G2', homeTeamId: 't3', awayTeamId: 't4' }, position: { x: 0, y: 0 } },\n        { id: 'g3', type: 'game', parentId: 'stage1', data: { standing: 'G3' }, position: { x: 0, y: 0 } },\n      ];\n\n      const edges: FlowEdge[] = [\n        { id: 'e1', type: 'gameToGame', source: 'g1', target: 'g3', sourceHandle: 'winner', targetHandle: 'home', data: { sourcePort: 'winner', targetPort: 'home' } } as GameToGameEdge,\n        { id: 'e2', type: 'gameToGame', source: 'g2', target: 'g3', sourceHandle: 'winner', targetHandle: 'away', data: { sourcePort: 'winner', targetPort: 'away' } } as GameToGameEdge,\n      ];\n\n      const { result } = renderHook(() => useFlowValidation(nodes, edges, [], [], [], validMetadata));\n      // g1 and g2 are valid (have teams)\n      // g3 is valid (has edges for both ports)\n      expect(result.current.isValid).toBe(true);\n    });\n  });\n\n  describe('Official Playing Validation', () => {\n    it('should detect when official matches home team via v1 edges', () => {\n      const nodes: FlowNode[] = [\n        {\n          id: 'field1',\n          type: 'field',\n          data: { name: 'Field 1', order: 0 },\n          position: { x: 0, y: 0 },\n        },\n        {\n          id: 'stage1',\n          type: 'stage',\n          parentId: 'field1',\n          data: { name: 'Stage 1', order: 0 },\n          position: { x: 0, y: 0 },\n        },\n        {\n          id: 'team1',\n          type: 'team',\n          parentId: 'stage1',\n          data: { label: 'Team A', reference: { type: 'static', name: 'Team A' } },\n          position: { x: 0, y: 0 },\n        },\n        {\n          id: 'game1',\n          type: 'game',\n          parentId: 'stage1',\n          data: { standing: 'Game 1', official: { type: 'static', name: 'Team A' } },\n          position: { x: 0, y: 0 },\n        },\n      ];\n\n      const edges: FlowEdge[] = [\n        { id: 'e1', type: 'teamToGame', source: 'team1', target: 'game1', targetHandle: 'home', data: { targetPort: 'home' } } as TeamToGameEdge,\n      ];\n\n      const { result } = renderHook(() => useFlowValidation(nodes, edges, [], [], [], validMetadata));\n      const officialError = result.current.errors.find(e => e.type === 'official_playing');\n      expect(officialError).toBeDefined();\n    });\n\n    it('should detect when official matches away team via v1 edges', () => {\n      const nodes: FlowNode[] = [\n        {\n          id: 'field1',\n          type: 'field',\n          data: { name: 'Field 1', order: 0 },\n          position: { x: 0, y: 0 },\n        },\n        {\n          id: 'stage1',\n          type: 'stage',\n          parentId: 'field1',\n          data: { name: 'Stage 1', order: 0 },\n          position: { x: 0, y: 0 },\n        },\n        {\n          id: 'team1',\n          type: 'team',\n          parentId: 'stage1',\n          data: { label: 'Team B', reference: { type: 'static', name: 'Team B' } },\n          position: { x: 0, y: 0 },\n        },\n        {\n          id: 'game1',\n          type: 'game',\n          parentId: 'stage1',\n          data: { standing: 'Game 1', official: { type: 'static', name: 'Team B' } },\n          position: { x: 0, y: 0 },\n        },\n      ];\n\n      const edges: FlowEdge[] = [\n        { id: 'e1', type: 'teamToGame', source: 'team1', target: 'game1', targetHandle: 'away', data: { targetPort: 'away' } } as TeamToGameEdge,\n      ];\n\n      const { result } = renderHook(() => useFlowValidation(nodes, edges, [], [], [], validMetadata));\n      const officialError = result.current.errors.find(e => e.type === 'official_playing');\n      expect(officialError).toBeDefined();\n    });\n    it('should detect when official is playing in home slot', () => {\n      const nodes: FlowNode[] = [\n        {\n          id: 'field1',\n          type: 'field',\n          data: { name: 'Field 1', order: 0 },\n          position: { x: 0, y: 0 },\n        },\n        {\n          id: 'stage1',\n          type: 'stage',\n          parentId: 'field1',\n          data: { name: 'Stage 1', order: 0, progressionMode: 'manual' },\n          position: { x: 0, y: 0 },\n        },\n        {\n          id: 'game1',\n          type: 'game',\n          parentId: 'stage1',\n          data: {\n            standing: 'Game 1',\n            homeTeamId: 'team-a',\n            awayTeamId: 'team-b',\n            fieldId: 'field1',\n            official: 'team-a',\n            startTime: null,\n          },\n          position: { x: 0, y: 0 },\n        },\n      ];\n\n      const globalTeams: GlobalTeam[] = [\n        { id: 'team-a', label: 'Team A', groupId: null, order: 0 },\n        { id: 'team-b', label: 'Team B', groupId: null, order: 1 },\n      ];\n\n      const { result } = renderHook(() => useFlowValidation(nodes, [], [], globalTeams, [], validMetadata));\n\n      const officialError = result.current.errors.find(e => e.type === 'official_playing');\n      expect(officialError).toBeDefined();\n      expect(officialError?.messageParams).toEqual({\n        game: 'Game 1',\n        team: 'Team A'\n      });\n    });\n\n    it('should detect when official is playing in away slot', () => {\n      const nodes: FlowNode[] = [\n        {\n          id: 'field1',\n          type: 'field',\n          data: { name: 'Field 1', order: 0 },\n          position: { x: 0, y: 0 },\n        },\n        {\n          id: 'stage1',\n          type: 'stage',\n          parentId: 'field1',\n          data: { name: 'Stage 1', order: 0, progressionMode: 'manual' },\n          position: { x: 0, y: 0 },\n        },\n        {\n          id: 'game1',\n          type: 'game',\n          parentId: 'stage1',\n          data: {\n            standing: 'Game 1',\n            homeTeamId: 'team-a',\n            awayTeamId: 'team-b',\n            fieldId: 'field1',\n            official: 'team-b',\n            startTime: null,\n          },\n          position: { x: 0, y: 0 },\n        },\n      ];\n\n      const globalTeams: GlobalTeam[] = [\n        { id: 'team-a', label: 'Team A', groupId: null, order: 0 },\n        { id: 'team-b', label: 'Team B', groupId: null, order: 1 },\n      ];\n\n      const { result } = renderHook(() => useFlowValidation(nodes, [], [], globalTeams, [], validMetadata));\n\n      const officialError = result.current.errors.find(e => e.type === 'official_playing');\n      expect(officialError).toBeDefined();\n      expect(officialError?.messageParams).toEqual({\n        game: 'Game 1',\n        team: 'Team B'\n      });\n    });\n  });\n\n  describe('Duplicate Standing Names', () => {\n    it('should warn about duplicate standing names', () => {\n      const nodes: FlowNode[] = [\n        {\n          id: 'field1',\n          type: 'field',\n          data: { name: 'Field 1', order: 0 },\n          position: { x: 0, y: 0 },\n        },\n        {\n          id: 'stage1',\n          type: 'stage',\n          parentId: 'field1',\n          data: { name: 'Stage 1', order: 0, progressionMode: 'manual' },\n          position: { x: 0, y: 0 },\n        },\n        {\n          id: 'game1',\n          type: 'game',\n          parentId: 'stage1',\n          data: {\n            standing: 'Group A',\n            homeTeamId: 'team1',\n            awayTeamId: 'team2',\n            fieldId: 'field1',\n            official: null,\n            startTime: null,\n          },\n          position: { x: 0, y: 0 },\n        },\n        {\n          id: 'game2',\n          type: 'game',\n          parentId: 'stage1',\n          data: {\n            standing: 'Group A',\n            homeTeamId: 'team3',\n            awayTeamId: 'team4',\n            fieldId: 'field1',\n            official: null,\n            startTime: null,\n          },\n          position: { x: 0, y: 0 },\n        },\n      ];\n\n      const { result } = renderHook(() => useFlowValidation(nodes, [], [], [], [], validMetadata));\n\n      expect(result.current.warnings.length).toBeGreaterThan(0);\n      const duplicateWarning = result.current.warnings.find(w => w.type === 'duplicate_standing');\n      expect(duplicateWarning).toBeDefined();\n      expect(duplicateWarning?.message).toContain('Group A');\n      expect(duplicateWarning?.message).toContain('2 games');\n    });\n\n    it('should not warn about unique standing names', () => {\n      const nodes: FlowNode[] = [\n        {\n          id: 'field1',\n          type: 'field',\n          data: { name: 'Field 1', order: 0 },\n          position: { x: 0, y: 0 },\n        },\n        {\n          id: 'stage1',\n          type: 'stage',\n          parentId: 'field1',\n          data: { name: 'Stage 1', order: 0, progressionMode: 'manual' },\n          position: { x: 0, y: 0 },\n        },\n        {\n          id: 'game1',\n          type: 'game',\n          parentId: 'stage1',\n          data: {\n            standing: 'Game 1',\n            homeTeamId: 'team1',\n            awayTeamId: 'team2',\n            fieldId: 'field1',\n            official: null,\n            startTime: null,\n          },\n          position: { x: 0, y: 0 },\n        },\n        {\n          id: 'game2',\n          type: 'game',\n          parentId: 'stage1',\n          data: {\n            standing: 'Game 2',\n            homeTeamId: 'team3',\n            awayTeamId: 'team4',\n            fieldId: 'field1',\n            official: null,\n            startTime: null,\n          },\n          position: { x: 0, y: 0 },\n        },\n      ];\n\n      const { result } = renderHook(() => useFlowValidation(nodes, [], [], [], [], validMetadata));\n\n      const duplicateWarning = result.current.warnings.find(w => w.type === 'duplicate_standing');\n      expect(duplicateWarning).toBeUndefined();\n    });\n  });\n\n  describe('Orphaned Teams', () => {\n    it('should warn about team with no outgoing connections', () => {\n      const nodes: FlowNode[] = [\n        {\n          id: 'field1',\n          type: 'field',\n          data: { name: 'Field 1', order: 0 },\n          position: { x: 0, y: 0 },\n        },\n        {\n          id: 'stage1',\n          type: 'stage',\n          parentId: 'field1',\n          data: { name: 'Stage 1', order: 0, progressionMode: 'manual' },\n          position: { x: 0, y: 0 },\n        },\n        {\n          id: 'team1',\n          type: 'team',\n          parentId: 'stage1',\n          data: {\n            label: 'Team A',\n            reference: { type: 'static', teamId: 'team-a' },\n          },\n          position: { x: 0, y: 0 },\n        },\n      ];\n\n      const { result } = renderHook(() => useFlowValidation(nodes, [], [], [], [], validMetadata));\n\n      expect(result.current.warnings.length).toBeGreaterThan(0);\n      const orphanWarning = result.current.warnings.find(w => w.type === 'orphaned_team');\n      expect(orphanWarning).toBeDefined();\n      expect(orphanWarning?.message).toContain('not connected to any game');\n    });\n\n    it('should not warn about team with connections', () => {\n      const nodes: FlowNode[] = [\n        {\n          id: 'field1',\n          type: 'field',\n          data: { name: 'Field 1', order: 0 },\n          position: { x: 0, y: 0 },\n        },\n        {\n          id: 'stage1',\n          type: 'stage',\n          parentId: 'field1',\n          data: { name: 'Stage 1', order: 0, progressionMode: 'manual' },\n          position: { x: 0, y: 0 },\n        },\n        {\n          id: 'team1',\n          type: 'team',\n          parentId: 'stage1',\n          data: {\n            label: 'Team A',\n            reference: { type: 'static', teamId: 'team-a' },\n          },\n          position: { x: 0, y: 0 },\n        },\n        {\n          id: 'game1',\n          type: 'game',\n          parentId: 'stage1',\n          data: {\n            standing: 'Game 1',\n            homeTeamId: null,\n            awayTeamId: 'team2',\n            fieldId: 'field1',\n            official: null,\n            startTime: null,\n          },\n          position: { x: 0, y: 0 },\n        },\n      ];\n\n      const edges: FlowEdge[] = [\n        {\n          id: 'edge1',\n          type: 'team-to-game',\n          source: 'team1',\n          target: 'game1',\n          targetHandle: 'home',\n        } as TeamToGameEdge,\n      ];\n\n      const { result } = renderHook(() => useFlowValidation(nodes, edges, [], [], [], validMetadata));\n\n      const orphanWarning = result.current.warnings.find(w => w.type === 'orphaned_team');\n      expect(orphanWarning).toBeUndefined();\n    });\n  });\n\n  describe('Container Hierarchy Validation', () => {\n    it('should error when game is not inside a stage', () => {\n      const nodes: FlowNode[] = [\n        {\n          id: 'field1',\n          type: 'field',\n          data: { name: 'Field 1', order: 0 },\n          position: { x: 0, y: 0 },\n        },\n        {\n          id: 'game1',\n          type: 'game',\n          parentId: null,\n          data: {\n            standing: 'Game 1',\n            homeTeamId: 'team1',\n            awayTeamId: 'team2',\n            fieldId: null,\n            official: null,\n            startTime: null,\n          },\n          position: { x: 0, y: 0 },\n        },\n      ];\n\n      const { result } = renderHook(() => useFlowValidation(nodes, [], [], [], [], validMetadata));\n\n      expect(result.current.isValid).toBe(false);\n      const containerError = result.current.errors.find(e => e.type === 'game_outside_container');\n      expect(containerError).toBeDefined();\n      expect(containerError?.message).toContain('must be inside a stage container');\n    });\n\n    it('should error when stage is not inside a field', () => {\n      const nodes: FlowNode[] = [\n        {\n          id: 'stage1',\n          type: 'stage',\n          parentId: null,\n          data: { name: 'Stage 1', order: 0, progressionMode: 'manual' },\n          position: { x: 0, y: 0 },\n        },\n      ];\n\n      const { result } = renderHook(() => useFlowValidation(nodes, [], [], [], [], validMetadata));\n\n      expect(result.current.isValid).toBe(false);\n      const containerError = result.current.errors.find(e => e.type === 'stage_outside_field');\n      expect(containerError).toBeDefined();\n      expect(containerError?.message).toContain('not inside a field container');\n    });\n\n    it('should error when game parent is not a valid stage', () => {\n      const nodes: FlowNode[] = [\n        {\n          id: 'field1',\n          type: 'field',\n          data: { name: 'Field 1', order: 0 },\n          position: { x: 0, y: 0 },\n        },\n        {\n          id: 'game1',\n          type: 'game',\n          parentId: 'field1', // Invalid: game parent must be stage\n          data: {\n            standing: 'Game 1',\n            homeTeamId: 'team1',\n            awayTeamId: 'team2',\n            fieldId: null,\n            official: null,\n            startTime: null,\n          },\n          position: { x: 0, y: 0 },\n        },\n      ];\n\n      const { result } = renderHook(() => useFlowValidation(nodes, [], [], [], [], validMetadata));\n\n      expect(result.current.isValid).toBe(false);\n      const containerError = result.current.errors.find(e => e.id === 'game1_outside_container');\n      expect(containerError).toBeDefined();\n      expect(containerError?.messageKey).toBe('game_invalid_parent');\n    });\n\n    it('should error when team node has no parent stage', () => {\n      const nodes: FlowNode[] = [\n        {\n          id: 'team1',\n          type: 'team',\n          parentId: undefined, // Missing parent\n          data: {\n            label: 'Team A',\n            reference: { type: 'static', teamId: 'team-a' },\n          },\n          position: { x: 0, y: 0 },\n        },\n      ];\n\n      const { result } = renderHook(() => useFlowValidation(nodes, [], [], [], [], validMetadata));\n\n      expect(result.current.isValid).toBe(false);\n      const containerError = result.current.errors.find(e => e.id === 'team1_outside_container');\n      expect(containerError).toBeDefined();\n      expect(containerError?.messageKey).toBe('team_outside_container');\n    });\n\n    it('should error when team parent is not a valid stage', () => {\n      const nodes: FlowNode[] = [\n        {\n          id: 'field1',\n          type: 'field',\n          data: { name: 'Field 1', order: 0 },\n          position: { x: 0, y: 0 },\n        },\n        {\n          id: 'team1',\n          type: 'team',\n          parentId: 'field1', // Invalid: team parent must be stage\n          data: {\n            label: 'Team A',\n            reference: { type: 'static', teamId: 'team-a' },\n          },\n          position: { x: 0, y: 0 },\n        },\n      ];\n\n      const { result } = renderHook(() => useFlowValidation(nodes, [], [], [], [], validMetadata));\n\n      expect(result.current.isValid).toBe(false);\n      const containerError = result.current.errors.find(e => e.type === 'team_outside_container');\n      expect(containerError).toBeDefined();\n      expect(containerError?.messageKey).toBe('team_invalid_parent');\n    });\n\n    it('should error when stage parent is not a valid field', () => {\n      const nodes: FlowNode[] = [\n        {\n          id: 'stage1',\n          type: 'stage',\n          parentId: 'nonexistent',\n          data: { name: 'Stage 1', order: 0, progressionMode: 'manual' },\n          position: { x: 0, y: 0 },\n        },\n      ];\n\n      const { result } = renderHook(() => useFlowValidation(nodes, [], [], [], [], validMetadata));\n\n      expect(result.current.isValid).toBe(false);\n      const containerError = result.current.errors.find(e => e.type === 'stage_outside_field');\n      expect(containerError).toBeDefined();\n      expect(containerError?.messageKey).toBe('stage_invalid_parent');\n    });\n  });\n\n  describe('Legacy and Error Handling', () => {\n    it('should handle legacy fieldId for time overlap validation', () => {\n      const nodes: FlowNode[] = [\n        {\n          id: 'game1',\n          type: 'game',\n          parentId: null,\n          data: {\n            standing: 'Game 1',\n            homeTeamId: 'team1',\n            awayTeamId: 'team2',\n            fieldId: 'field1',\n            startTime: '10:00',\n            duration: 50,\n          },\n          position: { x: 0, y: 0 },\n        },\n        {\n          id: 'game2',\n          type: 'game',\n          parentId: null,\n          data: {\n            standing: 'Game 2',\n            homeTeamId: 'team3',\n            awayTeamId: 'team4',\n            fieldId: 'field1',\n            startTime: '10:30',\n            duration: 50,\n          },\n          position: { x: 0, y: 0 },\n        },\n      ];\n\n      const { result } = renderHook(() => useFlowValidation(nodes, [], [{ id: 'field1', name: 'Field 1', order: 0 }], [], [], validMetadata));\n\n      expect(result.current.errors).toHaveLength(3); // 2 hierarchy errors + 1 overlap error\n      const overlapError = result.current.errors.find(e => e.type === 'field_overlap');\n      expect(overlapError).toBeDefined();\n      expect(overlapError?.message).toContain('Field 1');\n    });\n\n    it('should handle invalid time formats gracefully in overlaps', () => {\n      const nodes: FlowNode[] = [\n        {\n          id: 'field1',\n          type: 'field',\n          data: { name: 'Field 1', order: 0 },\n          position: { x: 0, y: 0 },\n        },\n        {\n          id: 'stage1',\n          type: 'stage',\n          parentId: 'field1',\n          data: { name: 'Stage 1', order: 0 },\n          position: { x: 0, y: 0 },\n        },\n        {\n          id: 'game1',\n          type: 'game',\n          parentId: 'stage1',\n          data: {\n            standing: 'Game 1',\n            startTime: 'invalid',\n            homeTeamId: 't1',\n            awayTeamId: 't2',\n          },\n          position: { x: 0, y: 0 },\n        },\n      ];\n\n      const { result } = renderHook(() => useFlowValidation(nodes, [], [], [], [], validMetadata));\n      expect(result.current.isValid).toBe(true);\n    });\n\n    it('should use field name from nodes if fields array is incomplete', () => {\n      const nodes: FlowNode[] = [\n        {\n          id: 'field1',\n          type: 'field',\n          data: { name: 'Real Field Name', order: 0 },\n          position: { x: 0, y: 0 },\n        },\n        {\n          id: 'stage1',\n          type: 'stage',\n          parentId: 'field1',\n          data: { name: 'Stage 1', order: 0 },\n          position: { x: 0, y: 0 },\n        },\n        {\n          id: 'game1',\n          type: 'game',\n          parentId: 'stage1',\n          data: { standing: 'G1', startTime: '10:00', duration: 60, homeTeamId: 't1', awayTeamId: 't2' },\n          position: { x: 0, y: 0 },\n        },\n        {\n          id: 'game2',\n          type: 'game',\n          parentId: 'stage1',\n          data: { standing: 'G2', startTime: '10:30', duration: 60, homeTeamId: 't3', awayTeamId: 't4' },\n          position: { x: 0, y: 0 },\n        },\n      ];\n\n      // Pass empty fields array\n      const { result } = renderHook(() => useFlowValidation(nodes, [], [], [], [], validMetadata));\n\n      const overlapError = result.current.errors.find(e => e.type === 'field_overlap');\n      expect(overlapError).toBeDefined();\n      expect(overlapError?.message).toContain('Real Field Name');\n    });\n\n    it('should fallback to Unknown Field if field name cannot be determined', () => {\n      const nodes: FlowNode[] = [\n        {\n          id: 'stage1',\n          type: 'stage',\n          parentId: 'nonexistent-field',\n          data: { name: 'Stage 1', order: 0 },\n          position: { x: 0, y: 0 },\n        },\n        {\n          id: 'game1',\n          type: 'game',\n          parentId: 'stage1',\n          data: { standing: 'G1', startTime: '10:00', duration: 60, homeTeamId: 't1', awayTeamId: 't2' },\n          position: { x: 0, y: 0 },\n        },\n        {\n          id: 'game2',\n          type: 'game',\n          parentId: 'stage1',\n          data: { standing: 'G2', startTime: '10:30', duration: 60, homeTeamId: 't3', awayTeamId: 't4' },\n          position: { x: 0, y: 0 },\n        },\n      ];\n\n      const { result } = renderHook(() => useFlowValidation(nodes, [], [], [], [], validMetadata));\n\n      const overlapError = result.current.errors.find(e => e.type === 'field_overlap');\n      expect(overlapError).toBeDefined();\n      expect(overlapError?.message).toContain('Unknown Field');\n    });\n\n    it('should skip time overlap check for games without any field ID', () => {\n      const nodes: FlowNode[] = [\n        {\n          id: 'game1',\n          type: 'game',\n          parentId: null,\n          data: {\n            standing: 'G1',\n            startTime: '10:00',\n            fieldId: null, // No field\n          },\n          position: { x: 0, y: 0 },\n        },\n      ];\n\n      const { result } = renderHook(() => useFlowValidation(nodes, [], [], [], [], validMetadata));\n      expect(result.current.errors.find(e => e.type === 'field_overlap')).toBeUndefined();\n    });\n  });\n\n  describe('Self-Play Validation', () => {\n    const nodes: FlowNode[] = [\n      { id: 'f1', type: 'field', data: { name: 'F1', order: 0 }, position: { x: 0, y: 0 } },\n      { id: 's1', type: 'stage', parentId: 'f1', data: { name: 'S1', order: 0 }, position: { x: 0, y: 0 } },\n    ];\n\n    it('should detect when same static team ID is assigned to both slots', () => {\n      const gameNodes: FlowNode[] = [\n        ...nodes,\n        {\n          id: 'g1',\n          type: 'game',\n          parentId: 's1',\n          data: { standing: 'G1', homeTeamId: 't1', awayTeamId: 't1' },\n          position: { x: 0, y: 0 },\n        },\n      ];\n\n      const { result } = renderHook(() => useFlowValidation(gameNodes, [], [], [], [], validMetadata));\n      const error = result.current.errors.find(e => e.type === 'self_reference');\n      expect(error).toBeDefined();\n      expect(error?.messageKey).toBe('self_play');\n    });\n\n    it('should detect when same dynamic source is assigned to both slots', () => {\n      const gameNodes: FlowNode[] = [\n        ...nodes,\n        { id: 'g1', type: 'game', parentId: 's1', data: { standing: 'G1', homeTeamId: 't1', awayTeamId: 't2' }, position: { x: 0, y: 0 } },\n        { id: 'g2', type: 'game', parentId: 's1', data: { standing: 'G2' }, position: { x: 0, y: 0 } },\n      ];\n\n      const edges: FlowEdge[] = [\n        { id: 'e1', type: 'gameToGame', source: 'g1', target: 'g2', sourceHandle: 'winner', targetHandle: 'home' } as GameToGameEdge,\n        { id: 'e2', type: 'gameToGame', source: 'g1', target: 'g2', sourceHandle: 'winner', targetHandle: 'away' } as GameToGameEdge,\n      ];\n\n      const { result } = renderHook(() => useFlowValidation(gameNodes, edges, [], [], [], validMetadata));\n      const error = result.current.errors.find(e => e.type === 'self_reference');\n      expect(error).toBeDefined();\n      expect(error?.message).toContain('same dynamic source');\n    });\n\n    it('should allow winner vs loser of same game', () => {\n      const gameNodes: FlowNode[] = [\n        ...nodes,\n        { id: 'g1', type: 'game', parentId: 's1', data: { standing: 'G1', homeTeamId: 't1', awayTeamId: 't2' }, position: { x: 0, y: 0 } },\n        { id: 'g2', type: 'game', parentId: 's1', data: { standing: 'G2' }, position: { x: 0, y: 0 } },\n      ];\n\n      const edges: FlowEdge[] = [\n        { id: 'e1', type: 'gameToGame', source: 'g1', target: 'g2', sourceHandle: 'winner', targetHandle: 'home' } as GameToGameEdge,\n        { id: 'e2', type: 'gameToGame', source: 'g1', target: 'g2', sourceHandle: 'loser', targetHandle: 'away' } as GameToGameEdge,\n      ];\n\n      const { result } = renderHook(() => useFlowValidation(gameNodes, edges, [], [], [], validMetadata));\n      const error = result.current.errors.find(e => e.type === 'self_reference');\n      expect(error).toBeUndefined();\n    });\n  });\n\n  describe('Cyclic Stage Reference Validation', () => {\n    it('should detect when a game references its own parent Ranking Stage', () => {\n      const nodes: FlowNode[] = [\n        { id: 'f1', type: 'field', data: { name: 'F1', order: 0 }, position: { x: 0, y: 0 } },\n        { id: 's1', type: 'stage', parentId: 'f1', data: { name: 'S1', order: 0, stageType: 'RANKING' }, position: { x: 0, y: 0 } },\n        { id: 'g1', type: 'game', parentId: 's1', data: { standing: 'G1' }, position: { x: 0, y: 0 } },\n      ];\n\n      const edges: FlowEdge[] = [\n        {\n          id: 'e1',\n          type: 'stageToGame',\n          source: 's1',\n          target: 'g1',\n          targetHandle: 'home',\n          data: { sourceRank: 1, targetPort: 'home' },\n        } as FlowEdge,\n      ];\n\n      const { result } = renderHook(() => useFlowValidation(nodes, edges, [], [], [], validMetadata));\n      const error = result.current.errors.find(e => e.id.startsWith('cyclic_stage_ref_'));\n      expect(error).toBeDefined();\n      expect(error?.message).toContain('cannot reference its own ranking');\n    });\n  });\n\n  describe('Memoization', () => {\n    it('should return same result for same inputs', () => {\n      const nodes: FlowNode[] = [\n        {\n          id: 'field1',\n          type: 'field',\n          data: { name: 'Field 1', order: 0 },\n          position: { x: 0, y: 0 },\n        },\n      ];\n\n      const { result, rerender } = renderHook(\n        ({ nodes, edges }) => useFlowValidation(nodes, edges, [], [], [], validMetadata),\n        { initialProps: { nodes, edges: [] } }\n      );\n\n      const firstResult = result.current;\n      rerender({ nodes, edges: [] });\n      const secondResult = result.current;\n\n      // useMemo returns same object reference when inputs haven't changed\n      expect(firstResult).toStrictEqual(secondResult);\n    });\n\n    it('should recompute when nodes change', () => {\n      const nodes1: FlowNode[] = [\n        {\n          id: 'field1',\n          type: 'field',\n          data: { name: 'Field 1', order: 0 },\n          position: { x: 0, y: 0 },\n        },\n      ];\n\n      const nodes2: FlowNode[] = [\n        {\n          id: 'field1',\n          type: 'field',\n          data: { name: 'Field 1', order: 0 },\n          position: { x: 0, y: 0 },\n        },\n        {\n          id: 'field2',\n          type: 'field',\n          data: { name: 'Field 2', order: 1 },\n          position: { x: 0, y: 0 },\n        },\n      ];\n\n      const { result, rerender } = renderHook(\n        ({ nodes, edges }) => useFlowValidation(nodes, edges, [], [], [], validMetadata),\n        { initialProps: { nodes: nodes1, edges: [] } }\n      );\n\n      const firstResult = result.current;\n      rerender({ nodes: nodes2, edges: [] });\n      const secondResult = result.current;\n\n      expect(firstResult).not.toBe(secondResult);\n    });\n  });\n\n  describe('Mandatory Metadata', () => {\n    it('should error when name is missing', () => {\n      const metadata = { name: '', date: '2026-01-01', start: '10:00' } as any;\n      const { result } = renderHook(() => useFlowValidation([], [], [], [], [], metadata));\n      \n      const error = result.current.errors.find(e => e.id === 'metadata_name_missing');\n      expect(error).toBeDefined();\n      expect(error?.message).toContain('Name is mandatory');\n    });\n\n    it('should error when date is missing', () => {\n      const metadata = { name: 'Test', date: '', start: '10:00' } as any;\n      const { result } = renderHook(() => useFlowValidation([], [], [], [], [], metadata));\n      \n      const error = result.current.errors.find(e => e.id === 'metadata_date_missing');\n      expect(error).toBeDefined();\n      expect(error?.message).toContain('Date is mandatory');\n    });\n\n    it('should error when start time is missing', () => {\n      const metadata = { name: 'Test', date: '2026-01-01', start: '' } as any;\n      const { result } = renderHook(() => useFlowValidation([], [], [], [], [], metadata));\n      \n      const error = result.current.errors.find(e => e.id === 'metadata_start_missing');\n      expect(error).toBeDefined();\n      expect(error?.message).toContain('Start Time is mandatory');\n    });\n\n    it('should return valid when all mandatory metadata is present', () => {\n      const metadata = { name: 'Test', date: '2026-01-01', start: '10:00' } as any;\n      const { result } = renderHook(() => useFlowValidation([], [], [], [], [], metadata));\n      \n      const errors = result.current.errors.filter(e => e.id.startsWith('metadata_'));\n      expect(errors).toHaveLength(0);\n    });\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/hooks/__tests__/useNodesState-manual-time.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/hooks/__tests__/useNodesState.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/hooks/__tests__/useTeamPoolState.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/hooks/__tests__/useValidation.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/hooks/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/hooks/useDesigner.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/hooks/useDesignerController.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/hooks/useEdgesState.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/hooks/useFlowState.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/hooks/useFlowValidation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/hooks/useNodesState.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/hooks/useTeamPoolState.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/hooks/useValidation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/i18n/__tests__/config.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/i18n/config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/i18n/testConfig.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/i18n/types.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/i18n/useTypedTranslation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/setupTests.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/types/__tests__/designer.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/types/__tests__/flowchart-containers.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/types/__tests__/flowchart.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/types/api.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/types/designer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/types/flowchart.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/types/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/types/tournament.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/utils/__tests__/TournamentGenerationEmptyPool.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'vi' is defined but never used.","line":1,"column":32,"nodeType":"Identifier","messageId":"unusedVar","endLine":1,"endColumn":34,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"vi"},"fix":{"range":[29,33],"text":""},"desc":"Remove unused variable \"vi\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'initialPool' is assigned a value but never used.","line":39,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":39,"endColumn":22},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":76,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":76,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2780,2783],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2780,2783],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":80,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":80,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2962,2965],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2962,2965],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, it, expect, vi } from 'vitest';\nimport { generateTournament } from '../tournamentGenerator';\nimport { assignTeamsToTournamentGames, generateTeamsForTournament } from '../teamAssignment';\nimport type { TournamentTemplate, TournamentGenerationConfig } from '../../types/tournament';\nimport type { GlobalTeam } from '../../types/flowchart';\n\ndescribe('Tournament Generation with Empty Initial Pool (#697)', () => {\n  const templateF6: TournamentTemplate = {\n    id: 'F6-2-2',\n    name: '6 Teams - 2 Groups of 3',\n    teamCount: { min: 6, max: 6, exact: 6 },\n    fieldOptions: [1, 2],\n    stages: [\n      {\n        name: 'Group Stage',\n        category: 'preliminary',\n        progressionMode: 'round_robin',\n        config: { mode: 'round_robin', teamCount: 3, doubleRound: false },\n        fieldAssignment: 'split',\n        splitCount: 2,\n      },\n      {\n        name: 'Playoffs',\n        category: 'final',\n        progressionMode: 'placement',\n        config: { mode: 'placement', positions: 4, format: 'single_elimination' },\n        fieldAssignment: 0,\n      }\n    ],\n    timing: {\n      firstGameStartTime: '10:00',\n      defaultGameDuration: 30,\n      defaultBreakBetweenGames: 5,\n    },\n  };\n\n  it('TDD RED: should correctly group teams in split stages when pool was initially empty', () => {\n    // Simulate empty initial pool\n    const initialPool: GlobalTeam[] = [];\n    \n    // Simulate generated teams (what useDesignerController does)\n    const teamCount = 6;\n    const teamData = generateTeamsForTournament(teamCount);\n    const generatedTeams: GlobalTeam[] = teamData.map((data, i) => ({\n        id: `t${i+1}`,\n        label: data.label,\n        color: data.color,\n        groupId: 'tournament-group',\n        order: i\n    }));\n\n    const config: TournamentGenerationConfig = {\n      template: templateF6,\n      fieldCount: 2,\n      startTime: '10:00',\n    };\n\n    // 1. Generate Structure\n    const structure = generateTournament(generatedTeams, config);\n\n    // Verify 2 stages in order 0 (split)\n    const groupStages = structure.stages.filter(s => s.data.order === 0);\n    expect(groupStages).toHaveLength(2);\n    expect(groupStages[0].data.name).toBe('Group Stage A');\n    expect(groupStages[1].data.name).toBe('Group Stage B');\n\n    // 2. Assign Teams\n    const operations = assignTeamsToTournamentGames(structure, generatedTeams);\n\n    // Verify assignments for Group Stage A (should have Team 1, 2, 3)\n    const stageAGames = structure.games.filter(g => g.parentId === groupStages[0].id);\n    const stageBGames = structure.games.filter(g => g.parentId === groupStages[1].id);\n\n    const teamIdsInA = new Set(operations\n        .filter(op => op.type === 'assign_team' && stageAGames.some(g => g.id === op.gameId))\n        .map(op => (op as any).teamId));\n    \n    const teamIdsInB = new Set(operations\n        .filter(op => op.type === 'assign_team' && stageBGames.some(g => g.id === op.gameId))\n        .map(op => (op as any).teamId));\n\n    // Group A should have teams t1, t2, t3\n    expect(teamIdsInA).toContain('t1');\n    expect(teamIdsInA).toContain('t2');\n    expect(teamIdsInA).toContain('t3');\n    expect(teamIdsInA).not.toContain('t4');\n\n    // Group B should have teams t4, t5, t6\n    expect(teamIdsInB).toContain('t4');\n    expect(teamIdsInB).toContain('t5');\n    expect(teamIdsInB).toContain('t6');\n    expect(teamIdsInB).not.toContain('t1');\n  });\n});","usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/utils/__tests__/bracketEdgeGenerator.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/utils/__tests__/edgeAnalysis.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/utils/__tests__/flowchartExport-containers.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/utils/__tests__/flowchartExport.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/utils/__tests__/flowchartImport.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/utils/__tests__/gameGenerators.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/utils/__tests__/jsonExport.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/utils/__tests__/rankingEngine.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/utils/__tests__/scrollHelpers.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/utils/__tests__/searchEngine.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/utils/__tests__/teamAssignment.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/utils/__tests__/teamReference.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/utils/__tests__/timeCalculation.format.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/utils/__tests__/timeCalculation.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/utils/__tests__/tournamentConstants.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/utils/__tests__/tournamentGeneration-complete.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/utils/__tests__/tournamentGenerator-timing.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/utils/__tests__/tournamentGenerator.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/utils/bracketEdgeGenerator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/utils/edgeAnalysis.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/utils/flowchartExport.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/utils/flowchartImport.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/utils/gameGenerators.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/utils/iconConstants.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/utils/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/utils/jsonExport.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/utils/rankingEngine.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/utils/roundRobinLogic.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/utils/scrollHelpers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/utils/searchEngine.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/utils/teamAssignment.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/utils/teamReference.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/utils/timeCalculation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/utils/tournamentConstants.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/utils/tournamentGenerator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/cda/dev/leaguesphere/gameday_designer/src/utils/tournamentTemplates.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]